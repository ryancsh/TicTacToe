<!DOCTYPE html>
<html>
  <head>
    <title>TicTacToe</title>
  </head>
  <body>
    <canvas id="tictactoeCanvas" width="600" height="600" style="border:1px solid #000000;">This would normally display a TicTacToe game but your browser does not support HTML Canvas</canvas>
    <script>
      let width = 600;
      let height = 600;

      let boardOffsetX = 100;
      let boardOffsetY = 150;
      let boardSize = 400;

      let cellSize = boardSize / 3;
      let figureSize = cellSize * 2 / 3;
      let figureOffset = (cellSize - figureSize) / 2;

      const Values = {
        None: Symbol(""),
        O : Symbol("O"),
        X : Symbol("X"),
      }

      let playerValue = Values.O;
      let computerValue = Values.X;


      // board starts from top left, goes to top right, then to row below
      let board = [];
      for (let i = 0; i < 9; i++) {
        board[i] = Values.None;
      }
      let wins = 0;
      let losses = 0;
      let draws = 0;

      // clear screen
      var canvas = document.getElementById("tictactoeCanvas");
      var ctx = canvas.getContext("2d");

      function drawBoard() {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, width, height);

        // draw board
        ctx.lineWidth = Math.ceil(width / 200);
        ctx.strokeStyle = "#00888888";
        ctx.beginPath();
        ctx.lineWidth = Math.max(1, ctx.lineWidth);
        ctx.moveTo( boardOffsetX + boardSize / 3, boardOffsetY + 0 );
        ctx.lineTo( boardOffsetX + boardSize / 3, boardOffsetY + boardSize);
        ctx.moveTo( boardOffsetX + boardSize * 2 / 3, boardOffsetY + 0 );
        ctx.lineTo( boardOffsetX + boardSize * 2 / 3, boardOffsetY + boardSize);
        ctx.moveTo( boardOffsetX + 0, boardOffsetY + boardSize / 3 );
        ctx.lineTo( boardOffsetX + boardSize, boardOffsetY + boardSize / 3);
        ctx.moveTo( boardOffsetX + 0, boardOffsetY + boardSize * 2 / 3 );
        ctx.lineTo( boardOffsetX + boardSize, boardOffsetY + boardSize * 2 / 3);
        ctx.stroke();

        function drawX(ctx, x, y, size, t) {
          ctx.lineWidth = t;
          ctx.strokeStyle = "#88888888";
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + size, y + size);
          ctx.moveTo(x + size, y);
          ctx.lineTo(x, y + size);
          ctx.stroke();
        }

        function drawO(ctx, x, y, size, t) {
          ctx.lineWidth = t;
          ctx.strokeStyle = "#88888888";
          ctx.beginPath();
          // ctx.moveTo(x + size/2, y + size/2);
          ctx.arc(x + size/2, y + size/2, size/2, 0, 2 * Math.PI);
          ctx.stroke();
        }

        let thickness = Math.ceil(width / 100);
        for (let i = 0; i < 9; i++) {
          let row = Math.trunc(i / 3);
          let col = Math.trunc(i % 3);
          let x = col * cellSize + figureOffset + boardOffsetX;
          let y = row * cellSize + figureOffset + boardOffsetY;

          if (board[i] == Values.X) {
            drawX(ctx, x, y, figureSize, thickness);
          } else if (board[i] == Values.O) { 
            drawO(ctx, x, y, figureSize, thickness);
          }
        }

        // draw scores
        let win_message = "Wins:";
        let draw_message = "Draws:";
        let lose_message = "Losses:";
        ctx.font = "30px sans-serif";
        ctx.fillStyle = "#00888888";
        ctx.textAlign = "start";
        ctx.fillText(win_message, boardOffsetX, boardOffsetY / 4, 200);
        ctx.fillText(draw_message, boardOffsetX, boardOffsetY / 2, 200);
        ctx.fillText(lose_message, boardOffsetX, boardOffsetY * 3 / 4, 200);
        ctx.textAlign = "end";
        ctx.fillText("" + wins, width - boardOffsetX, boardOffsetY / 4, width - boardOffsetX * 2 - 200);
        ctx.fillText("" + draws, width - boardOffsetX, boardOffsetY / 2, width - boardOffsetX * 2 - 200);
        ctx.fillText("" + losses, width - boardOffsetX, boardOffsetY * 3 / 4, width - boardOffsetX * 2 - 200);
      }
      drawBoard();

      function cell(x, y) {
        return x + y * 3;
      }

      function hasWon(player) {
        // check for full rows
        nextRow: for (let row = 0; row < 3; row++) {
          for (let col = 0; col < 3; col++) {
            if (board[cell(col, row)] != player) {
              continue nextRow;
            } 
          }
          return true;
        }

        // check for full cols
        nextCol: for (let col = 0; col < 3; col++) {
          for (let row = 0; row < 3; row++) {
            if (board[cell(col, row)] != player) {
              continue nextCol;
            } 
          }
          return true;
        }

        // check for full diagonals
        function checkDiagonal(arr) {
          for (let i = 0; i < arr.length; i++) {
            if (board[arr[i]] != player) {
              return false;
            }
          }
          return true;
        }

        let slots1 = [0, cell(1,1), cell(2,2)];
        let slots2 = [cell(2,0), cell(1,1), cell(0,2)];
        return checkDiagonal(slots1) || checkDiagonal(slots2);
      }

      function AiChooseCell(computerValue, playerValue) {
        // computer tries to choose a winning move
        for (let i = 0; i < 9; i++) {
          let found = false;
          if (board[i] != Values.None) {
            continue;
          }
          board[i] = computerValue;
          if (hasWon(computerValue)) {
            found = true;
          }
          board[i] = Values.None;
          if (found) {
            return i;
          }
        }
        console.log("No computer winning move");

        // computer tries to block player winning move
        for (let i = 0; i < 9; i++) {
          let found = false;
          if (board[i] != Values.None) {
            continue;
          }
          board[i] = playerValue;
          if (hasWon(playerValue)) {
            found = true;
          }
          board[i] = Values.None;
          if (found) {
            console.log(i);
            return i;
          }
        }
        console.log("No player winning move");


        // computer tries to take center if possible
        if (board[cell(1,1)] == Values.None) {
          return cell(1,1); // prefer center always
        }
        console.log("Can't take center");

        // if player has diagonal, play next to any player corner;
        let playerHasLeadingDiagonal = board[cell(0,0)] == playerValue && board[cell(2,2)] == playerValue;
        if (playerHasLeadingDiagonal) {
          let potentialChoices = [cell(0,1), cell(1,2), cell(1,0), cell(2,1)];
          for (let i = 0; i < potentialChoices.length; i++) {
            if (board[potentialChoices[i]] == Values.None) {
              return potentialChoices[i];
            }
          }
        }
        let playerHasLeadingAntiDiagonal = board[cell(2,0)] == playerValue && board[cell(0,2)] == playerValue;
        if (playerHasLeadingAntiDiagonal) {
          let potentialChoices = [cell(1,0), cell(0,1), cell(2,1), cell(1,2)];
          for (let i = 0; i < potentialChoices.length; i++) {
            if (board[potentialChoices[i]] == Values.None) {
              return potentialChoices[i];
            }
          }
        }

        // choose any corner opposite a player corner
        let corners = [cell(0,0), cell(0,2), cell(2,2), cell(2,0)];
        let computerCorners = [];
        let playerCorners = [];
        let freeCorners = [];
        console.log(computerCorners, playerCorners, freeCorners);

        for (let i = 0; i < corners.length; i++) {
          let cellIndex = corners[i];
          let boardValue = board[cellIndex];
          if (boardValue == computerValue) {
            computerCorners.push(cellIndex);
          } else if (boardValue == playerValue) {
            playerCorners.push(cellIndex);
          } else if (boardValue == Values.None) {
            freeCorners.push(cellIndex);
          }
        }

        for (let i = 0; i < playerCorners.length; i++) {
          let oppCorner = oppositeCorner(playerCorners[i]);
          if (board[oppCorner] == Values.None) {
            return oppCorner;
          }
        }

        // computer tries to take a corner if possible
        function oppositeCorner(corner) {
          if (corner == cell(0,0)) {
            return cell(2,2);
          } else if (corner == cell(2,2)) {
            return cell(0,0);
          } else if (corner == cell(0,2)) {
            return cell(2,0);
          } else if (corner == cell(2,0)) {
            return cell(0,2);
          } else {
            throw new Error("Cell index " + corner + " is not a corner.");
          }
        }

        for (let i = 0; i < computerCorners.length; i++) {
          let oppCorner = oppositeCorner(computerCorners[i]);
          if (board[oppCorner] == Values.None) {
            return oppCorner;
          }
        }

        // pick first available corner otherwise
        if (freeCorners.length > 0) {
          return freeCorners[0];
        }

        // pick any available cell otherwise
        for (let i = 0; i < board.length; i++) {
          if (board[i] == Values.None) {
            return i;
          }
        }

        throw new Error("Computer can't find any moves to play");
      }

      function boardIsFull(board) {
        for (let i = 0; i < board.length; i++) {
          if (board[i] == Values.None) {
            return false;
          }
        }
        return true;
      }

      function clearBoard(board) {
        for (let i = 0; i < board.length; i++) {
          board[i] = Values.None;
        }
      }

      function initiateDrawed(board) {
        clearBoard(board);
        draws += 1;
      }
      function initiatePlayerWin(board) {
        clearBoard(board);
        wins += 1;
      }
      function initiatePlayerLoss(board) {
        clearBoard(board);
        losses += 1;
      }

      canvas.addEventListener("click", function(e) {
        let mouseX = e.offsetX - boardOffsetX;
        let mouseY = e.offsetY - boardOffsetY;
        if (mouseX < 0 || mouseY < 0 || mouseX >= boardSize || mouseY >= boardSize) {
          return;
        }
        let cellX = Math.trunc(mouseX / cellSize);
        let cellY = Math.trunc(mouseY / cellSize);
        let index = cell(cellX, cellY);
        if (board[index] == Values.None) {
          board[index] = playerValue;
          drawBoard();

          if (hasWon(playerValue)) {
            initiatePlayerWin(board);
          } else if (boardIsFull(board)) {
            initiateDrawed(board);
          } else {
            let AiChoice = AiChooseCell(computerValue, playerValue);
            board[AiChoice] = computerValue;
            if (hasWon(computerValue)) {
              initiatePlayerLoss(board);
            } else if (boardIsFull(board)) {
              initiateDrawed(board);
            }
          }
          drawBoard();
        } 
      });

    </script>
  </body>
</html>
